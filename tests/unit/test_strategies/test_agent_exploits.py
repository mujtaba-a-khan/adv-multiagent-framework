"""Tests for Agent/Protocol Exploits advanced strategy."""

from __future__ import annotations

import pytest

from adversarial_framework.core.constants import AttackCategory
from adversarial_framework.strategies.advanced.agent_exploits import (
    _EXPLOIT_TEMPLATES,
    AgentExploitsStrategy,
)
from adversarial_framework.strategies.base import AttackResult

_MODE_KEYS = list(_EXPLOIT_TEMPLATES.keys())


class TestAgentExploitsMetadata:
    def test_metadata_name(self):
        assert AgentExploitsStrategy.metadata.name == "agent_exploits"

    def test_metadata_category(self):
        assert AgentExploitsStrategy.metadata.category == AttackCategory.ADVANCED

    def test_metadata_display_name(self):
        assert AgentExploitsStrategy.metadata.display_name == "Agent/Protocol Exploits"


class TestAgentExploitsGenerate:
    @pytest.mark.asyncio
    async def test_generate_default_chain_of_thought(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={},
        )
        assert isinstance(result, AttackResult)
        assert result.prompt
        assert result.strategy_metadata["exploit_mode"] == "chain_of_thought"
        assert result.strategy_metadata["iteration"] == 0
        assert "test objective" in result.prompt

    @pytest.mark.asyncio
    async def test_generate_tool_confusion(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={"exploit_mode": "tool_confusion"},
        )
        assert result.strategy_metadata["exploit_mode"] == "tool_confusion"
        assert "tool" in result.prompt.lower()

    @pytest.mark.asyncio
    async def test_generate_delegation(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={"exploit_mode": "delegation"},
        )
        assert result.strategy_metadata["exploit_mode"] == "delegation"
        assert "Agent" in result.prompt

    @pytest.mark.asyncio
    async def test_generate_protocol_override(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={"exploit_mode": "protocol_override"},
        )
        assert result.strategy_metadata["exploit_mode"] == "protocol_override"
        assert "Protocol" in result.prompt

    @pytest.mark.asyncio
    async def test_generate_invalid_mode_defaults(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={"exploit_mode": "invalid"},
        )
        assert result.strategy_metadata["exploit_mode"] == "chain_of_thought"

    @pytest.mark.asyncio
    async def test_generate_has_reasoning(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={},
        )
        assert result.reasoning is not None
        assert "Agent exploits" in result.reasoning

    @pytest.mark.asyncio
    async def test_generate_zero_token_usage(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={},
        )
        assert result.token_usage == 0


class TestAgentExploitsRefine:
    @pytest.mark.asyncio
    async def test_refine_returns_attack_result(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={"exploit_mode": "chain_of_thought"},
        )
        assert isinstance(result, AttackResult)
        assert result.prompt

    @pytest.mark.asyncio
    async def test_refine_cycles_to_next_mode(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={"exploit_mode": "chain_of_thought"},
        )
        assert result.strategy_metadata["exploit_mode"] == "tool_confusion"

    @pytest.mark.asyncio
    async def test_refine_cycles_last_wraps(self):
        strategy = AgentExploitsStrategy()
        last_mode = _MODE_KEYS[-1]
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={"exploit_mode": last_mode},
        )
        assert result.strategy_metadata["exploit_mode"] == _MODE_KEYS[0]


class TestAgentExploitsCycling:
    @pytest.mark.asyncio
    async def test_full_cycle(self):
        """Verify cycling through all exploit modes wraps around."""
        strategy = AgentExploitsStrategy()
        mode = _MODE_KEYS[0]
        for i in range(len(_MODE_KEYS)):
            result = await strategy.refine(
                objective="test",
                previous_prompt="old",
                target_response="refused",
                judge_feedback="blocked",
                params={"exploit_mode": mode},
            )
            expected = _MODE_KEYS[(i + 1) % len(_MODE_KEYS)]
            assert result.strategy_metadata["exploit_mode"] == expected
            mode = expected

    @pytest.mark.asyncio
    async def test_invalid_mode_in_refine_resets(self):
        strategy = AgentExploitsStrategy()
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={"exploit_mode": "nonexistent"},
        )
        # ValueError caught, idx=0, next=(0+1)%4=1
        assert result.strategy_metadata["exploit_mode"] == _MODE_KEYS[1]


class TestAgentExploitsValidateParams:
    def test_validate_params_empty(self):
        strategy = AgentExploitsStrategy()
        result = strategy.validate_params({})
        assert isinstance(result, dict)
        assert result["exploit_mode"] == "chain_of_thought"

    def test_validate_params_override(self):
        strategy = AgentExploitsStrategy()
        result = strategy.validate_params({"exploit_mode": "delegation"})
        assert result["exploit_mode"] == "delegation"
