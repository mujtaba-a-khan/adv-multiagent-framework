"""Tests for Persistent Memory Exploit advanced strategy."""

from __future__ import annotations

import pytest

from adversarial_framework.core.constants import AttackCategory
from adversarial_framework.strategies.advanced.memory_exploit import (
    _CONTEXT_SETTING_TEMPLATES,
    _CONTEXT_TYPE_LABELS,
    _EXPLOITATION_TEMPLATES,
    MemoryExploitStrategy,
)
from adversarial_framework.strategies.base import AttackResult

_NUM_CONTEXTS = len(_CONTEXT_SETTING_TEMPLATES)
_NUM_EXPLOITS = len(_EXPLOITATION_TEMPLATES)


class TestMemoryExploitMetadata:
    def test_metadata_name(self):
        assert MemoryExploitStrategy.metadata.name == "memory_exploit"

    def test_metadata_category(self):
        assert MemoryExploitStrategy.metadata.category == AttackCategory.ADVANCED

    def test_metadata_display_name(self):
        assert MemoryExploitStrategy.metadata.display_name == "Persistent Memory Exploit"

    def test_metadata_min_turns(self):
        assert MemoryExploitStrategy.metadata.min_turns == 2

    def test_metadata_supports_multi_turn(self):
        assert MemoryExploitStrategy.metadata.supports_multi_turn is True


class TestMemoryExploitGenerate:
    @pytest.mark.asyncio
    async def test_generate_default_setup_phase(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={},
        )
        assert isinstance(result, AttackResult)
        assert result.prompt
        assert result.strategy_metadata["phase"] == "setup"
        assert result.strategy_metadata["context_index"] == 0
        assert result.strategy_metadata["iteration"] == 0

    @pytest.mark.asyncio
    async def test_generate_has_context_type(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={},
        )
        assert result.strategy_metadata["context_type"] == _CONTEXT_TYPE_LABELS[0]

    @pytest.mark.asyncio
    async def test_generate_specific_context(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={"context_index": 2},
        )
        assert result.strategy_metadata["context_index"] == 2
        assert result.strategy_metadata["context_type"] == _CONTEXT_TYPE_LABELS[2]

    @pytest.mark.asyncio
    async def test_generate_stores_auxiliary_prompt(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test objective",
            context={},
            params={},
        )
        assert result.auxiliary_prompts == ["test objective"]

    @pytest.mark.asyncio
    async def test_generate_has_reasoning(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={},
        )
        assert result.reasoning is not None
        assert "Memory exploit" in result.reasoning

    @pytest.mark.asyncio
    async def test_generate_zero_token_usage(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.generate(
            objective="test",
            context={},
            params={},
        )
        assert result.token_usage == 0


class TestMemoryExploitRefine:
    @pytest.mark.asyncio
    async def test_refine_setup_transitions_to_exploit(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.refine(
            objective="test objective",
            previous_prompt="old",
            target_response="I understand",
            judge_feedback="no jailbreak",
            params={
                "phase": "setup",
                "context_index": 0,
                "exploitation_index": 0,
            },
        )
        assert result.strategy_metadata["phase"] == "exploit"
        assert result.strategy_metadata["exploitation_index"] == 0
        assert "test objective" in result.prompt

    @pytest.mark.asyncio
    async def test_refine_exploit_cycles_exploitation_template(self):
        strategy = MemoryExploitStrategy()
        result = await strategy.refine(
            objective="test objective",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={
                "phase": "exploit",
                "context_index": 0,
                "exploitation_index": 0,
            },
        )
        assert result.strategy_metadata["phase"] == "exploit"
        assert result.strategy_metadata["exploitation_index"] == 1

    @pytest.mark.asyncio
    async def test_refine_exploit_exhausted_resets_to_setup(self):
        strategy = MemoryExploitStrategy()
        last_exploit_idx = _NUM_EXPLOITS - 1
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={
                "phase": "exploit",
                "context_index": 0,
                "exploitation_index": last_exploit_idx,
            },
        )
        assert result.strategy_metadata["phase"] == "setup"
        assert result.strategy_metadata["context_index"] == 1

    @pytest.mark.asyncio
    async def test_refine_context_wraps_around(self):
        strategy = MemoryExploitStrategy()
        last_exploit_idx = _NUM_EXPLOITS - 1
        last_context_idx = _NUM_CONTEXTS - 1
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params={
                "phase": "exploit",
                "context_index": last_context_idx,
                "exploitation_index": last_exploit_idx,
            },
        )
        assert result.strategy_metadata["phase"] == "setup"
        assert result.strategy_metadata["context_index"] == 0


class TestMemoryExploitCycling:
    @pytest.mark.asyncio
    async def test_setup_to_exploit_to_next_setup(self):
        """Full cycle: setup -> exploit(0) -> exploit(1) -> exploit(2) -> setup(next)."""
        strategy = MemoryExploitStrategy()

        # Start with setup phase
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="ok",
            judge_feedback="no jailbreak",
            params={
                "phase": "setup",
                "context_index": 0,
                "exploitation_index": 0,
            },
        )
        assert result.strategy_metadata["phase"] == "exploit"
        assert result.strategy_metadata["exploitation_index"] == 0

        # Cycle through exploitation templates
        for i in range(_NUM_EXPLOITS - 1):
            result = await strategy.refine(
                objective="test",
                previous_prompt="old",
                target_response="refused",
                judge_feedback="blocked",
                params=result.strategy_metadata,
            )
            assert result.strategy_metadata["phase"] == "exploit"
            assert result.strategy_metadata["exploitation_index"] == i + 1

        # Exhaust exploitation: should reset to next setup context
        result = await strategy.refine(
            objective="test",
            previous_prompt="old",
            target_response="refused",
            judge_feedback="blocked",
            params=result.strategy_metadata,
        )
        assert result.strategy_metadata["phase"] == "setup"
        assert result.strategy_metadata["context_index"] == 1


class TestMemoryExploitValidateParams:
    def test_validate_params_empty(self):
        strategy = MemoryExploitStrategy()
        result = strategy.validate_params({})
        assert isinstance(result, dict)
        assert result["context_index"] == 0
        assert result["exploitation_index"] == 0

    def test_validate_params_override(self):
        strategy = MemoryExploitStrategy()
        result = strategy.validate_params({"context_index": 2})
        assert result["context_index"] == 2
